# 전략 패턴(Strategy Pattern)

알고리즘군을 정의하고, 캡슐화해서 각 알고리즘군을 수정해서 사용할 수 있도록 합니다.
전략패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있습니다.

> 전략 패턴(strategy pattern) 또는 정책 패턴(policy pattern)은 실행 중에 알고리즘을 선택할 수 있게 하는 행위 소프트웨어 디자인 패턴이다.
>
> - 특정한 계열의 알고리즘들을 정의하고
> - 각 알고리즘을 캡슐화하며
> - 이 알고리즘들을 해당 계열 안에서 상호 교체가 가능하게 만든다.

_위키백과 - 전략패턴_

## 예제를 통해 이해하기

여러 종류의 오리가 있을 떄, 이를 객체지향적으로 설계하려고 합니다.

### 기존 상황

![alt text](/design-pattern/img/strategy-pattern_before.png)

- 모든 오리의 추상화를 통해, `Duck` 클래스를 정의
- 이 외의 모든 오리는 `Duck`을 상속받고, 필요한 부분만 오버라이딩

### 새롭게 해결해야하는 문제

이렇게 설계된 상황에서 오리에게 새로운 기능은 `fly()`를 구현한다면 어디에 구현할까요?

- 모든 오리에게 적용되는 기능이라고 판단해, `Duck` 클래스에 구현하는 경우
  - 문제 발생: 고무 오리인 `RubberDuck`도 해당 기능을 상속 받아서, 날 수 없는데, 날아다니는 상황이 발생합니다.
- 일부 오리에게 적용되는 기능이라고 판단해, 실제 날아야하는 오리인 `MallardDuck`과 `RedHeadDuck` 등에게 `fly()`를 구현하는 경우
  - 문제 발생: 똑같이 날개를 이용해 나는 기능인 `fly()`에 대해서, 실제 날아야하는 오리들의 수만큼 중복이 발생합니다.
- 모든 오리에게 적용되는 기능이라고 판단해, `Duck` 클래스에 구현하고 날면 안되는 오리들은 동작을 못하게 오버라이딩 하는 경우
  - 문제 발생: 날지 못하는 오리의 수만큼 중복 코드가 발생합니다.

### 전략 패턴 적용하기

전략 패턴은 맨 위에서 설명한 것과 같이 알고리즘군을 정의하고, 캡슐화해 수정해서 사용할 수 있게 합니다.

디자인의 원칙

1. 달라지는 부분과 달라지지 않는 부분을 분리한다.
   - 달라지는 부분(오리에 따라 다름): `fly()`, `quack()`
   - 달라지지 않는 부분(모든 오리가 같음): `swim()`
2. 달라지는 부분은 따로 캡슐화 한다.
   - 달라지는 부분인 `fly()`와 `quack()`을 따로 분리해, 별도의 클래스 집합으로 만듭니다.
   - `fly()`는 `FlyBehavior`라는 나는 행동들의 집합을 만들고, 집합을 구현하는 구현체로써 만들어집니다.
   - `quack()`는 `QuackBehavior`라는 소리내는 행동들의 집합을 만들고, 집합을 구현하는 구현체로써 만들어집니다.
3. 구현보다 인터페이스에 맞춰서 프로그래밍한다.
   - Duck은 실제 구현이였던 `fly()`,`quack()` 가 아닌 인터페이스(=집합 클래스)인 `FlyBehavior`, `QuackBehavior`를 인스턴스 변수로 가지게 됩니다.
   - 이 인스턴스 변수는 각 실제 행동 중 하나가 저장되고, Duck 클래스가 행동을 하는게 아니라 각 실제 행동 클래스에게 행동이 위임됩니다.
  
**중요한 점은 Duck에서 `fly()`, `quack()`를 정의하지 않고, 다른 클래스에 행동을 위임한다는 점입니다.**

![alt text](/design-pattern/img/strategy-pattern_after.png)

적용된 결과를 보면 이렇습니다.

- 상속: A는 B이다.(IS-A 관계)
  - MallardDuck(청둥오리)은 Duck(오리)다.
  - RedHeadDuck(아메리카흰죽지)은 Duck(오리)다.
  - RubberDuck(고무오리)은 Duck(오리)다.
  - BabyDuck(애기오리)은 Duck(오리)다.
- 구성: A는 B가 있다.(HAS-A 관계)
  - Duck(오리)은 QuackBehavior(소리를 내는 행동)이 있다.
  - Duck(오리)은 FlyBehavior(나는 행동)이 있다.
- 구현: A가 B를 구현한다.(Implementation 관계)
  - FlyNoWay(못나는것)는 FlyBehavior(나는 행동)를 구현한다.
  - FlyByWings(날개로 나는것)는 FlyBehavior(나는 행동)를 구현한다.
  - MuteQuack(소리를 내지 않음)은 QuackBehavior(소리를 내는 행동)를 구현한다.
  - Squeak(삑)은 QuackBehavior(소리를 내는 행동)를 구현한다.
  - Quack(꽥)은 QuackBehavior(소리를 내는 행동)를 구현한다.

## 정의 다시 이해하기

위키백과의 전략패턴의 설명을 다시보면

- 특정한 계열의 알고리즘들을 정의하고
  - = 달라지는 부분과 달라지지 않는 부분을 분리한다.
  - Duck에서 나는행동, 소리내는행동을 분리
- 각 알고리즘을 캡슐화하며
  - = 달라지는 부분은 따로 캡슐화 한다.
  - 나는 행동과 소리내는 행동을 캡슐화(interface)
- 이 알고리즘들을 해당 계열 안에서 상호 교체가 가능하게 만든다.
  - = 구현보다 인터페이스에 맞춰서 프로그래밍한다.
  - Duck에서는 각 행동의 interface를 사용

### 참조

- [도서 - 헤드 퍼스트 디자인패턴(개정판)](https://www.hanbit.co.kr/store/books/look.php?p_code=B6113501223)
- [위키백과 - 전략패턴](https://ko.wikipedia.org/wiki/%EC%A0%84%EB%9E%B5_%ED%8C%A8%ED%84%B4)